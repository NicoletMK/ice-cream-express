<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ice Cream Express üç¶</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --road-fast: #f5f5f5;
            --road-slow: #e6bf83; 
            --obstacle: #d0d9e6;  
            
            /* Thematic A* Viz Colors */
            --bot-path: #1976D2;        /* Dark Blue - Final Path */
            --visited: #b3e5fc;         /* Light Blue - To-Check List (Open Set) */
            --current-node: #1976D2;    /* Dark Blue - Checking NOW! */
            --closed-set-node: #d0d9e6; /* Grey - Already Checked (Closed Set) */

            
            --player-path: #f06292;
            --player-visited: #f8bbd0;
            --border: #a1887f;
            --player-dark: #c2185b;
            --bot-dark: #1976d2;
            --text-dark: #424242;
            --bg-light: #fafafa;
            --white: #ffffff;
            --shadow: rgba(0, 0, 0, 0.1);
            --unicorn-gradient: linear-gradient(45deg, #ffafcc, #e2b6ff, #c8b6ff, #ffc8dd);
            --success-green: #4CAF50;
            --success-green-dark: #388E3C;
            --neutral-grey: #78909c;
            --neutral-grey-dark: #455a64;
            --overlay-bg: rgba(250, 250, 250, 0.85);
        }

        * { box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body { font-family: 'Poppins', sans-serif; background-color: var(--bg-light); color: var(--text-dark); text-align: center; margin: 0; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; }
        .page-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-light); z-index: 2000; display: flex; justify-content: center; align-items: center; padding: 20px; }
        #user-info-page .popup-content { text-align: left; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-weight: 600; margin-bottom: 5px; color: var(--text-dark); }
        .form-group input { width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 1.1em; font-family: 'Poppins', sans-serif; }
        .form-group input:focus { outline: none; border-color: var(--player-path); box-shadow: 0 0 8px var(--player-visited); }
        #navigation-page .popup-content { text-align: center; max-width: 850px; }

        #welcome-title, #app-container > h1 {
            font-family: 'Fredoka One', cursive;
            font-size: clamp(2.2em, 5vw, 3em);
            margin: 0 0 10px 0;
            text-shadow: 2px 2px 5px var(--shadow);
            background: var(--unicorn-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }
        #app-container > h1 { margin-bottom: 5px; }

        .nav-buttons { display: flex; flex-direction: column; gap: 15px; margin-top: 25px; }
        .nav-buttons button:not(.tutorial-btn) { width: 100%; font-size: 1.3em; padding: 16px; }

        .level-intro { background: var(--white); border-radius: 12px; padding: 15px 20px; text-align: left; border: 1px solid #eee; margin-bottom: 5px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
        .level-intro h3 { font-family: 'Fredoka One', cursive; color: var(--player-dark); margin: 0 0 10px 0; font-size: 1.4em; border-bottom: 2px solid var(--player-path); padding-bottom: 5px; }
        .level-intro p { font-size: 0.95em; line-height: 1.5; margin: 0 0 10px 0; }
        .level-intro ul { padding-left: 20px; list-style: '‚úî '; margin: 0; font-size: 0.9em; list-style-position: inside; }
        .level-intro li { margin-bottom: 6px; padding-left: 5px; }
        .level-intro ul ul { margin-top: 5px; padding-left: 15px; list-style: 'üî∏ '; }
        .level-intro strong { font-weight: 600; }
        
        /* --- General Button Styles --- */
        button { font-family: 'Fredoka One', cursive; font-size: 1.1em; padding: 14px 30px; border: none; border-radius: 12px; cursor: pointer; color: white; transition: all 0.2s ease; }
        button.player-btn { background-color: var(--player-path); box-shadow: 0 4px var(--player-dark); }
        button.player-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: 0 2px var(--player-dark); }
        button.bot-btn { background-color: var(--bot-path); box-shadow: 0 4px var(--bot-dark); }
        button.bot-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: 0 2px var(--bot-dark); }
        button.neutral-btn { background-color: var(--neutral-grey); box-shadow: 0 4px var(--neutral-grey-dark); }
        button.neutral-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: 0 2px var(--neutral-grey-dark); }
        button.finish-game-btn { background-color: var(--success-green); box-shadow: 0 4px var(--success-green-dark); }
        button.finish-game-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: 0 2px var(--success-green-dark); }
        button:disabled { background-color: #bdbdbd; box-shadow: 0 4px #757575; cursor: not-allowed; opacity: 0.7; }

        /* --- Tutorial Button Style --- */
        .tutorial-btn {
            font-size: 1em; 
            padding: 8px 18px; 
            margin: 5px auto 15px auto; 
            display: inline-block; 
            width: auto; 
            background-color: var(--neutral-grey); 
            box-shadow: 0 4px var(--neutral-grey-dark);
        }
         .tutorial-btn:active:not(:disabled) {
             transform: translateY(2px);
            box-shadow: 0 2px var(--neutral-grey-dark);
         }
        
        /* --- INTRO CAROUSEL STYLES --- */
        #intro-popup-overlay { 
            background-color: var(--overlay-bg);
            backdrop-filter: blur(5px); 
            z-index: 2001; 
        }
        #intro-popup-overlay *{box-sizing:border-box}
        #intro-popup-overlay .wrap{ min-height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:20px; gap:18px; font-family: 'Poppins', sans-serif; width: 100%; }
        #intro-popup-overlay h1{ margin:0; font-size:clamp(18px,3vw,26px); text-align:center; font-family: 'Fredoka One', cursive; color: var(--text-dark); }
        #intro-popup-overlay .stage{ width:75vh; height:75vh; max-width:90vw; max-height:90vw; background:linear-gradient(180deg,#fff,#f6f6f6); border-radius:12px; box-shadow:0 8px 22px rgba(20,20,40,0.12); display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative; border:1px solid rgba(0,0,0,0.06); }
        #intro-popup-overlay .media{width:100%;height:100%;display:flex;align-items:center;justify-content:center}
        #intro-popup-overlay .media img{max-width:100%;max-height:100%;object-fit:contain;display:block}
        #intro-popup-overlay .media video{max-width:100%;max-height:100%;display:block}
        #intro-popup-overlay .controls{display:flex;gap:12px;align-items:center}
        #intro-popup-overlay .controls button { padding: 10px 14px; font-size: 1em;} 
        #intro-popup-overlay #intro-prev-btn, #intro-popup-overlay #intro-next-btn { background-color: var(--bot-path); box-shadow: 0 4px var(--bot-dark); }
        #intro-popup-overlay #intro-prev-btn:active:not(:disabled), #intro-popup-overlay #intro-next-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: 0 2px var(--bot-dark); }
        #intro-popup-overlay .controls button:disabled { background-color: #bdbdbd; box-shadow: 0 4px #757575; opacity: 0.7; }
        #intro-popup-overlay .status{ font-size:14px;color:#333; font-family: 'Poppins', sans-serif; font-weight: 600; }
        #intro-popup-overlay .hint{ position:absolute;left:12px;top:12px;background:rgba(255,255,255,0.7); padding:6px 8px;border-radius:8px;font-size:12px; font-family: 'Poppins', sans-serif; }
        #intro-popup-overlay .close-btn-style { position:absolute;top:10px;right:10px; background-color: var(--player-path); box-shadow: 0 4px var(--player-dark); padding:6px 10px;border-radius:6px; font-size: 1em; }
         #intro-popup-overlay .close-btn-style:active:not(:disabled) { transform: translateY(2px); box-shadow: 0 2px var(--player-dark); }
        @media (max-width:420px){ #intro-popup-overlay .stage{ width:340px; height: 340px; } }
        /* --- END INTRO STYLES --- */

        #app-container { width: 100%; max-width: 1100px; padding: 25px 15px; }

        #game-layout { display: flex; flex-direction: column; align-items: center; gap: 25px; }
        #game-board { display: grid; grid-template-columns: repeat(10, clamp(30px, 8vw, 52px)); grid-template-rows: repeat(10, clamp(30px, 8vw, 52px)); gap: 4px; background-color: var(--border); border: 6px solid var(--border); border-radius: 12px; padding: 6px; box-shadow: 0 8px 25px rgba(0,0,0,0.15); }
        .cell { border-radius: 6px; display: flex; justify-content: center; align-items: center; font-size: clamp(18px, 4vw, 26px); user-select: none; cursor: pointer; transition: transform 0.2s, background-color 0.3s; position: relative; }
        .cell .path-icon { position: absolute; width: 60%; height: 60%; bottom: 2px; right: 2px; opacity: 0.8; }
        .cell.road-fast { background-color: var(--road-fast); }
        .cell.road-slow { background-color: var(--road-slow); } 
        .cell.obstacle { background-color: var(--obstacle); cursor: not-allowed; }
        .cell.player-visited { background-color: var(--player-visited); }
        .cell.player-path { background-color: var(--player-path); }
        
        /* NEW A* VIZ STYLES */
        .cell.bot-path { background-color: var(--bot-path); } /* Dark Blue */
        .cell.visited { background-color: var(--closed-set-node); } /* Light Grey */
        .cell.next-consider { background-color: var(--visited); } /* Light Blue */
        .cell.current-bot-pos { 
            background-color: var(--current-node); /* Dark Blue */
            color: white;
            transform: scale(1.1); 
            box-shadow: 0 0 10px var(--current-node); 
            z-index: 10;
        }
        
        .cell.end-node-style { background: var(--unicorn-gradient) !important; border-radius: 50%; transform: scale(1.1); color: var(--text-dark); }
        #controls-info { background: var(--white); padding: 20px; border-radius: 20px; box-shadow: 0 4px 15px var(--shadow); width: 100%; max-width: 540px; border: 1px solid #eee; }
        #info-header { padding: 10px; border-radius: 12px; margin-bottom: 15px; transition: background-color 0.5s ease; background: var(--unicorn-gradient); }
        #info-header h2 { color: white; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); }
        #round-title { font-family: 'Fredoka One', cursive; font-size: 1.6em; margin: 0; }
        .stats-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 15px; 
            align-items: center; 
            margin-bottom: 15px; 
            font-weight: 600; 
            font-size: 1.1em; 
        }
        @media (min-width: 400px) {
            .stats-grid { grid-template-columns: 1fr 1fr 1fr; }
            #cost-display { grid-column: 1; }
            #time-display { grid-column: 2; }
            #tip-display { grid-column: 3; }
        }
        #time-display span { display: inline-block; width: 1.2em; text-align: center; }
        .meter-container { grid-column: 1 / -1; text-align: left; font-family: 'Fredoka One', cursive; }
        .meter-label { display: flex; justify-content: space-between; align-items: center; font-size: 1em; padding: 0 5px 5px 5px; }
        .meter-label .icon-group { display: flex; align-items: center; }
        .meter-label .icon-group .icon-display { width: 35px; height: 35px; }
        .bar { width: 100%; height: 25px; background-color: #e0e0e0; border-radius: 12.5px; overflow: hidden; border: 3px solid var(--white); box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }
        .bar-inner { height: 100%; transition: width 0.5s ease-out; border-radius: 9.5px; }
        .bar-inner.player-bar { background: linear-gradient(90deg, #f48fb1, var(--player-path)); }
        #message-box { font-size: 1.1em; font-weight: 600; min-height: 40px; margin: 20px 0; }
        
        /* Updated Button Group */
        #controls-info .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #controls-info .button-group button { 
            font-size: 1.1em; 
            padding: 14px;
            width: 100%;
        }
        #controls-info .button-group #rewatch-bot-btn {
             font-size: 1.0em;
             padding: 12px;
        }


        #results-comparison { text-align: left; margin-top: 20px; padding: 15px; background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 12px; }
        #results-comparison h4 { font-family: 'Fredoka One', cursive; margin: 0 0 10px 0; color: var(--bot-dark); }
        #results-comparison p { margin: 5px 0; font-weight: 600; }
        #results-comparison p span { font-weight: normal; }

        /* --- POPUP OVERLAY STYLES --- */
        .popup-overlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: var(--overlay-bg);
            backdrop-filter: blur(5px);
            z-index: 1000;
            display: flex; 
            justify-content: center; 
            align-items: center; 
            padding: 20px; 
        } 
        #intro-popup-overlay { z-index: 2001; }
        #rules-popup-overlay { z-index: 1500; } 
        #popup-overlay, #pre-bot-popup { z-index: 1000; } /* Main popup and new intro popup */

        .popup-content { 
            background: var(--white); 
            padding: 40px 50px; 
            border-radius: 20px; 
            box-shadow: 0 8px 30px rgba(0,0,0,0.12); 
            max-width: 1000px; 
            width: 100%; 
            position: relative; 
            text-align: center; 
            margin: auto; 
            max-height: calc(100vh - 40px); 
            overflow-y: auto; 
        }
        .close-x-btn { position: absolute; top: 15px; right: 25px; font-size: 2.5em; font-weight: bold; background: none; border: none; color: #aaa; cursor: pointer; line-height: 1; padding: 0; box-shadow: none; transition: color 0.2s; }
        .close-x-btn:hover { color: var(--text-dark); }
        .popup-content h3 { font-family: 'Fredoka One', cursive; font-size: 2.2em; margin-top: 0; color: var(--bot-dark); }
        .popup-content .popup-body-text { text-align: left; line-height: 1.7; font-size: 1.1em; max-width: 800px; margin: 15px auto; }
        .popup-content ul { max-width: 800px; margin: 15px auto; text-align: left;}
        .popup-content strong { color: var(--bot-dark); }
        .popup-content .popup-body-text .color-key { /* For A* explanation */
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #777;
            vertical-align: middle;
            margin: 0 5px;
        }
        
        /* RESTORED: A* Mini-Demo styles */
        .algorithm-explanation { margin-top: 25px; padding-top: 25px; border-top: 1px dashed #ccc;}
        .algorithm-explanation h4 { font-family: 'Fredoka One', cursive; color: var(--bot-dark); font-size: 1.6em; margin-bottom: 15px;}
        #algorithm-demo { display: flex; flex-direction: column; align-items: center; margin: 20px auto; gap: 25px; max-width: 900px; }
        #mini-game-board { display: grid; grid-template-columns: repeat(5, 50px); grid-template-rows: repeat(5, 50px); gap: 2px; background-color: var(--border); border: 4px solid var(--border); border-radius: 8px; padding: 4px; flex-shrink: 0; }
        #mini-game-board .cell { width: 50px; height: 50px; font-size: 1em; border-radius: 4px; position: relative; }
        #demo-controls { margin-top: 15px; display: flex; flex-direction: column; gap: 10px; }
        #explanation-text { text-align: center; margin-top: 15px; font-size: 1.1em; min-height: 50px; font-weight: 600; }
        #popup-button-group { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; margin-top: 20px; }
        #popup-button-group button { margin-top: 0; }
        @media (min-width: 950px) { 
            #algorithm-demo { flex-direction: row; align-items: flex-start; }
        }

        /* A* Cost Labels (for both demos) */
        .cost-label { 
            position: absolute; 
            top: 1px;
            left: 1px;
            background: rgba(255,255,255,0.9); 
            padding: 1px 3px; 
            font-size: clamp(0.4em, 2vw, 0.6em); 
            border-radius: 3px; 
            line-height: 1.1; 
            color: var(--text-dark); 
            font-weight: 600; 
            text-align: left;
            z-index: 5;
        }
        .cost-label span { display: block; }
        .cost-label .g-cost { color: var(--bot-dark); }
        .cost-label .h-cost { color: var(--player-dark); }
        .cost-label .f-cost { color: var(--success-green); font-weight: bold; }
        
        #play-again-options { display: flex; gap: 15px; justify-content: center; }

        #wrap-up-popup .popup-content { max-width: 650px; }
        #wrap-up-performance { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 12px; padding: 15px; margin-bottom: 20px; text-align: left; }
        #wrap-up-performance h4 { font-family: 'Fredoka One', cursive; margin: 0 0 10px 0; color: var(--text-dark); font-size: 1.3em; text-align: center; }
        #wrap-up-performance p { margin: 8px 0; font-size: 1.05em; line-height: 1.4; }
        #wrap-up-performance strong { color: var(--player-dark); }
        #wrap-up-reflection { text-align: left; margin-bottom: 25px; }
        #wrap-up-reflection h4 { font-family: 'Fredoka One', cursive; margin: 0 0 10px 0; color: var(--bot-dark); font-size: 1.3em; text-align: center; }
        #wrap-up-reflection p { font-size: 1.05em; line-height: 1.6; }
        #wrap-up-buttons { display: flex; flex-direction: column; gap: 15px; align-items: center; }
        #wrap-up-buttons button { width: 80%; font-size: 1.2em; padding: 15px; }

        @media (min-width: 950px) { 
            #game-layout { flex-direction: row; align-items: flex-start; } 
        }
        /* --- Cuter Bot Intro Popup Styles --- */
        .bot-intro-panel-left {
            flex-basis: 40%;
            background: var(--bot-path); /* Using the Bot's blue */
            padding: 50px 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
        }
        .bot-intro-panel-left .bot-intro-icon {
            font-size: 6em;
            line-height: 1;
            margin-bottom: 20px;
            animation: bot-bob 2s ease-in-out infinite; /* Fun animation! */
        }
        .bot-intro-panel-left .bot-intro-panel-title {
            font-family: 'Fredoka One', cursive;
            font-size: 2.2em;
            margin: 0 0 10px 0;
        }
        .bot-intro-panel-left p {
            font-size: 1.15em;
            line-height: 1.5;
        }

        .bot-intro-panel-right {
            flex-basis: 60%;
            padding: 50px 60px;
            background: var(--white);
            display: flex; 
            flex-direction: column;
            justify-content: center;
        }

        /* Fun bobbing animation for the robot */
        @keyframes bot-bob {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }

        /* Make it stack on small screens */
        @media (max-width: 768px) {
            #pre-bot-popup .popup-content {
                flex-direction: column;
                max-width: 500px;
                padding: 0;
            }
            .bot-intro-panel-left {
                padding: 40px 30px;
            }
            .bot-intro-panel-right {
                padding: 40px 30px;
                text-align: left; /* Keep text left-aligned */
            }
        }

        /* --- NEW: Bot Legend Styles --- */
        #bot-legend {
            text-align: left;
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa; /* Matches results box */
            border: 1px solid #e9ecef; /* Matches results box */
            border-radius: 12px;
        }
        #bot-legend h4 {
            font-family: 'Fredoka One', cursive;
            margin: 0 0 10px 0;
            color: var(--bot-dark);
            text-align: center;
            font-size: 1.1em; /* A nice size */
        }
        .color-key-list {
            list-style: none;
            padding-left: 0;
            font-size: 0.95em;
            margin: 0;
        }
        .color-key-list li {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .color-key-list li:last-child {
            margin-bottom: 0;
        }
        .color-key-list .color-key {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #777;
            vertical-align: middle;
            margin-right: 10px;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .color-key-list strong {
            color: var(--text-dark); /* Use regular text color */
            margin-right: 4px;
        }
    </style>
</head>
<body>

<div id="intro-popup-overlay" class="page-container" style="display: none;">
    <div class="wrap">
        <h1>How to Play Ice Cream Express!</h1>
        <div class="stage" aria-live="polite">
            <div class="hint">Use ‚óÄ ‚ñ∂ or swipe</div>
            <div id="media-container" class="media"></div>
            <button id="intro-close-btn" class="close-btn-style">‚úñ Close</button>
        </div>
        <div class="controls" role="group" aria-label="Carousel controls" style="position:relative; margin-top:15px;">
            <button id="intro-prev-btn">‚óÄ Back</button>
            <div class="status" id="intro-status">0 / 0</div>
            <button id="intro-next-btn">Next ‚ñ∂</button>
        </div>
    </div>
</div>

<div id="user-info-page" class="page-container" style="display: none;">
    <div class="popup-content" style="max-width: 600px;">
        <div style="font-size: 5em; margin-bottom: 10px; text-align: center;">üç¶</div>
        <h3 style="font-size: 2em; margin-top: 0; text-align: center;">Welcome to Ice Cream Express!</h3>
        <p style="font-size: 1.1em; margin-bottom: 25px; text-align: center;">Please enter your info to get started.</p>
        <form id="user-info-form">
            <div class="form-group"> <label for="first-name">First Name:</label> <input type="text" id="first-name" required> </div>
            <div class="form-group"> <label for="last-initial">Last Name Initial:</label> <input type="text" id="last-initial" maxlength="1" required> </div>
            <div class="form-group"> <label for="age">Age:</label> <input type="number" id="age" min="1" max="99" required> </div>
            <div class="form-group"> <label for="grade">Grade:</label> <input type="text" id="grade" required> </div>
            <button type="submit" class="player-btn" style="margin-top: 20px; width: 100%; font-size: 1.2em;">Save and Continue</button>
        </form>
    </div>
</div>

<div id="navigation-page" class="page-container" style="display: none;">
    <div class="popup-content">
        <div style="font-size: 5em; margin-bottom: 10px;">üç¶</div>
        <h1 id="welcome-title">Welcome, Trainee!</h1>
         <button id="nav-how-to-play" class="tutorial-btn neutral-btn">Watch the Tutorial üí°</button>
        <p style="font-size: 1.2em; line-height: 1.6;">Ready to deliver some delicious ice cream?</p>

        <div class="nav-buttons">
            <div class="level-intro">
                <h3>Delivery Challenge üç¶</h3>
                 <ul>
                     <li><strong>Your Mission:</strong> Deliver ice cream from üöö to üè† using the lowest *cost* path.</li>
                     <li><strong>The Clock is Ticking:</strong> A timer will run during your turns. Try to get a low time *and* a low cost!</li>
                     <li><strong>Map:</strong>
                        <ul>
                           <li>‚¨ú White Roads = Fast (Cost: 1)</li>
                           <li>üü´ Brown Roads = Slow (Cost: 3)</li>
                           <li>üå≥ Obstacles = Can't go through</li>
                        </ul>
                     </li>
                     <li><strong>Challenge:</strong> You'll play (Round 1), watch the A* Bot (Round 2), then try to beat its score (Round 3)!</li>
                 </ul>
            </div>
            <button id="nav-start-trainee" class="player-btn">Start Game</button>
        </div>
    </div>
</div>


<div id="game-container" style="display: none;">
    <div id="app-container">
        <h1>Ice Cream Express</h1>
        
         <div id="game-header-buttons" style="display: flex; justify-content: center; gap: 15px; margin-bottom: 15px;">
             <button id="game-how-to-play-btn" class="tutorial-btn neutral-btn" style="margin: 0;">Watch the Tutorial üí°</button>
             <button id="game-check-rules-btn" class="tutorial-btn neutral-btn" style="margin: 0;">Check the Rules üìú</button>
         </div>

        <div id="game-layout">
            <div id="game-board"></div>
            <div id="controls-info">
                <div id="info-header"> <h2 id="round-title"></h2> </div>
                <div class="stats-grid">
                    <div id="cost-display">Cost: 0</div>
                    <div id="time-display"><span>‚è±Ô∏è</span> 0.0s</div>
                    <div id="tip-display">Tip: $10.00</div>
                    <div class="meter-container">
                        <div class="meter-label"> <span>Tip Meter</span> <div> <span id="money-icon">ü§ë</span> <span id="ice-cream-icon">üç¶</span> </div> </div>
                        <div class="bar"><div id="tip-meter-bar" class="bar-inner player-bar" style="width: 100%;"></div></div>
                    </div>
                </div>
                <div id="message-box"></div>
                
                <div id="results-comparison" style="display: none;"></div>
                
                <div id="bot-legend" style="display: none;">
                    <h4>ü§ñ Bot's "Thinking" Colors</h4>
                    <ul class="color-key-list">
                        <li><span class="color-key" style="background:var(--current-node); border-color: var(--bot-dark);"></span> <strong>Dark Blue:</strong> "Checking NOW!"</li>
                        <li><span class="color-key" style="background:var(--visited);"></span> <strong>Light Blue:</strong> "To-Check List"</li>
                        <li><span class="color-key" style="background:var(--closed-set-node);"></span> <strong>Grey:</strong> "Already Checked"</li>
                    </ul>
                </div>
                <div class="button-group">
                    <button id="finish-btn" class="player-btn"></button>
                    <button id="rewatch-bot-btn" class="neutral-btn" style="display: none;"></button>
                    <button id="start-next-round-btn" class="player-btn" style="display: none;"></button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="pre-bot-popup" class="popup-overlay" style="display: none;">
    <div class="popup-content" style="max-width: 850px; padding: 0; overflow: hidden; display: flex; flex-direction: row;">
    
        <div class="bot-intro-panel-left">
            <div class="bot-intro-icon">ü§ñ</div>
            <h3 class="bot-intro-panel-title">Bot's Turn!</h3>
            <p>Get ready to watch the <strong>A* Search</strong> algorithm find the *perfect* path!</p>
            <p style="font-size: 0.9em; opacity: 0.8; margin-top: 15px;">(This is how a real GPS thinks!)</p>
        </div>

        <div class="bot-intro-panel-right">
            <h3 style="font-size: 1.8em; margin-top: 0; color: var(--bot-dark);">How the Bot "Thinks"</h3>
            
            <div class="popup-body-text" style="font-size: 1.05em; margin: 0 0 15px 0;">
                <p>The bot is smart! It checks two things for every square:</p>
                <ul style="margin-top: 10px; margin-bottom: 10px;">
                    <li><strong>G-Cost:</strong> The *actual cost* from the start (past).</li>
                    <li><strong>H-Cost:</strong> The *best guess* to the goal (future).</li>
                </ul>
                <p>It adds them to get an <strong>F-Score (G + H)</strong>, and always explores the square with the *lowest* F-Score first.</p>
                
                <p style="margin-top: 20px; font-weight: 600;">Watch for these colors:</p>
                <ul style="list-style: none; padding-left: 0; font-size: 0.95em; margin-top: 10px;">
                    <li><span class="color-key" style="background:var(--current-node); border-color: var(--bot-dark);"></span> <strong>Dark Blue:</strong> "Checking NOW!"</li>
                    <li><span class="color-key" style="background:var(--visited);"></span> <strong>Light Blue:</strong> "To-Check List"</li>
                    <li><span class="color-key" style="background:var(--closed-set-node);"></span> <strong>Grey:</strong> "Already Checked"</li>
                </ul>
            </div>

            <button id="start-bot-turn-btn" class="bot-btn" style="margin-top: 20px; width: 100%; font-size: 1.2em;">Watch the Bot!</button>
        </div>

    </div>
</div>

<div id="popup-overlay" class="popup-overlay" style="display: none;">
     <div class="popup-content">
        <button class="close-x-btn" id="close-x-btn">&times;</button>
        <h3 id="popup-title"></h3>
        <div id="popup-body"></div>
        
        <div id="algorithm-explanation-container" style="display: none;">
             <div class="algorithm-explanation">
                <h4>Watch the Bot Think! (A* Search)</h4>
                <div id="algorithm-demo">
                    <div id="mini-game-board"></div>
                    <div id="demo-controls">
                        <div id="explanation-text">Click "Next Step" to see how the bot thinks!</div>
                        <button id="prev-step-btn" class="bot-btn" disabled>Previous Step</button>
                        <button id="next-step-btn" class="bot-btn">Next Step!</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="popup-button-group">
            <button id="replay-mini-demo-btn" class="neutral-btn" style="display: none;">Replay Mini-Demo</button>
            <button id="popup-got-it-btn" class="player-btn">Got It!</button>
        </div>
        
    </div>
</div>

<div id="rules-popup-overlay" class="popup-overlay" style="display: none;">
     <div class="popup-content" style="max-width: 600px;">
        <button class="close-x-btn" id="rules-close-x-btn">&times;</button>
        <h3 id="rules-popup-title">Game Rules</h3>
        <div id="rules-popup-body"></div>
        <button id="rules-close-popup-btn" class="player-btn" style="margin-top: 20px;">Got It!</button>
    </div>
</div>

<div id="wrap-up-popup" class="page-container" style="display: none;">
     <div class="popup-content">
         <h3 id="wrap-up-title">Level Complete! üéâ</h3>
         <div id="wrap-up-performance"></div>
         <div id="wrap-up-reflection">
             <h4>Learning Reflection ü§î</h4>
             <p>Think about the paths you chose. Were they always the lowest cost? Were they the fastest (lowest time)? Sometimes the lowest cost path (using slow roads) takes more time to click! The bot uses <strong>A* Search</strong> to find the best path, just like real delivery companies use to plan routes!</p>
         </div>
         <div id="wrap-up-buttons"></div>
     </div>
</div>


<script>
document.addEventListener('DOMContentLoaded', () => {
    
    // --- SELECTORS ---
    const introPopupOverlay = document.getElementById('intro-popup-overlay'); 
    const userInfoPage = document.getElementById('user-info-page');
    const navigationPage = document.getElementById('navigation-page');
    const gameContainer = document.getElementById('game-container');
    const wrapUpPopup = document.getElementById('wrap-up-popup'); 
    const userInfoForm = document.getElementById('user-info-form');
    const welcomeTitle = document.getElementById('welcome-title');
    const navStartTraineeBtn = document.getElementById('nav-start-trainee');
    const navHowToPlayBtn = document.getElementById('nav-how-to-play'); 
    const gameHowToPlayBtn = document.getElementById('game-how-to-play-btn'); 
    const boardEl = document.getElementById('game-board'), messageBox = document.getElementById('message-box');
    const costDisplay = document.getElementById('cost-display');
    const tipDisplay = document.getElementById('tip-display');
    const timeDisplay = document.getElementById('time-display');
    const roundTitleEl = document.getElementById('round-title'); 
    const tipMeterBar = document.getElementById('tip-meter-bar');
    const finishBtn = document.getElementById('finish-btn');
    const startNextRoundBtn = document.getElementById('start-next-round-btn');
    const rewatchBotBtn = document.getElementById('rewatch-bot-btn'); // NEW
    const moneyIcon = document.getElementById('money-icon'), iceCreamIcon = document.getElementById('ice-cream-icon');
    const resultsComparisonEl = document.getElementById('results-comparison');
    
    // Popups
    const rulesPopupOverlay = document.getElementById('rules-popup-overlay');
    const rulesPopupTitle = document.getElementById('rules-popup-title');
    const rulesPopupBody = document.getElementById('rules-popup-body');
    const rulesCloseXBtn = document.getElementById('rules-close-x-btn');
    const rulesClosePopupBtn = document.getElementById('rules-close-popup-btn');
    const gameCheckRulesBtn = document.getElementById('game-check-rules-btn');

    // Pre-Bot Popup
    const preBotPopup = document.getElementById('pre-bot-popup');
    const startBotTurnBtn = document.getElementById('start-bot-turn-btn');

    // Main A* Teaching Popup
    const popupOverlay = document.getElementById('popup-overlay');
    const popupTitle = document.getElementById('popup-title');
    const popupBody = document.getElementById('popup-body');
    const closeXBtn = document.getElementById('close-x-btn');
    const algoExplanationContainer = document.getElementById('algorithm-explanation-container');
    const popupGotItBtn = document.getElementById('popup-got-it-btn'); // Renamed
    
    // Mini-demo
    const miniGameBoard = document.getElementById('mini-game-board');
    const explanationText = document.getElementById('explanation-text');
    const prevStepBtn = document.getElementById('prev-step-btn');
    const nextStepBtn = document.getElementById('next-step-btn');
    const replayMiniDemoBtn = document.getElementById('replay-mini-demo-btn'); // Renamed
    
    // Wrap-up
    const wrapUpTitle = document.getElementById('wrap-up-title');
    const wrapUpPerformance = document.getElementById('wrap-up-performance');
    const wrapUpButtons = document.getElementById('wrap-up-buttons');


    // --- GAME CONSTANTS & STATE ---
    const GRID_SIZE = 10, OBSTACLE_COUNT = 18;
    const FAST_ROAD_COST = 1; // Restored
    const SLOW_ROAD_COST = 3; // Restored
    const SLOW_ROAD_COUNT = 25; // Restored
    const MAX_TIP = 10.00;
    const MAX_COST_PENALTY = 40; // The cost at which the tip becomes $0
    
    let grid = [], startNode, endNode;
    let playerPath = [];
    let playerVisited = new Set();
    let playerCost = 0, botPathCost = 0, currentRound = 1;
    let botAStarLiveSteps = []; // For the main board demo
    
    let playerCostRound1 = 0, playerCostRound3 = 0;
    
    let roundTimerInterval = null;
    let roundStartTime = 0;
    let playerTimeRound1 = 0, playerTimeRound3 = 0;
    let botTime = 0; // For bot's animation

    // RESTORED: Mini-demo state
    let demoGrid, demoPath = [];
    let currentDemoStep = 0;

    // --- USER & PAGE MANAGEMENT ---
    let currentUser = null;
    let currentUserId = null;
    
    function showPage(pageId) {
        gameContainer.style.display = 'none';
        userInfoPage.style.display = 'none';
        navigationPage.style.display = 'none';
        wrapUpPopup.style.display = 'none'; 
        if (pageId === 'game-container') gameContainer.style.display = 'block';
        else if (pageId === 'user-info-page') userInfoPage.style.display = 'flex';
        else if (pageId === 'navigation-page') navigationPage.style.display = 'flex';
    }
    
    userInfoForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const userInfo = { 
            firstName: document.getElementById('first-name').value, 
            lastNameInitial: document.getElementById('last-initial').value, 
            age: document.getElementById('age').value, 
            grade: document.getElementById('grade').value, 
        };
        localStorage.setItem('iceCreamExpressUser', JSON.stringify(userInfo)); 
        currentUser = userInfo; 
        if (window.saveUserProfileToFirebase) { 
            window.saveUserProfileToFirebase(userInfo); 
        } else { 
            console.warn("Firebase user profile save function not found."); 
        }
        updateNavigationPage();
        showPage('navigation-page'); 
    });

    navStartTraineeBtn.addEventListener('click', () => { showPage('game-container'); setupGame(); });

    function openHowToPlayPopup() {
        carouselItems = level1TutorialItems; // Only one tutorial
        introPopupOverlay.style.display = 'flex'; 
        carouselRender(0); 
    }
    navHowToPlayBtn.addEventListener('click', openHowToPlayPopup);
    gameHowToPlayBtn.addEventListener('click', openHowToPlayPopup);


    function updateNavigationPage() {
        if (currentUser && currentUser.firstName) {
            welcomeTitle.textContent = `Welcome, ${currentUser.firstName}!`;
        } else {
             const storedUser = localStorage.getItem('iceCreamExpressUser');
               if(storedUser) {
                   currentUser = JSON.parse(storedUser);
                   welcomeTitle.textContent = `Welcome, ${currentUser.firstName}!`;
               } else {
                   welcomeTitle.textContent = `Welcome, Delivery Driver!`; 
               }
        }
    }

    function initializeAppFlow() {
        currentUserId = localStorage.getItem('iceCreamExpressUserId') || `user_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        localStorage.setItem('iceCreamExpressUserId', currentUserId);
        
        document.getElementById('first-name').value = '';
        document.getElementById('last-initial').value = '';
        document.getElementById('age').value = '';
        document.getElementById('grade').value = '';

         const storedUser = localStorage.getItem('iceCreamExpressUser');
         if (storedUser) {
             currentUser = JSON.parse(storedUser); 
         } else {
             currentUser = null;
         }
        showPage('user-info-page'); 
    }

    // --- Tutorial Carousel Script ---
    const level1TutorialItems = [
        {type: 'video', src: "1_page_before1st_round.mp4", alt: 'Intro Video 1'},
        {type: 'video', src: "2_page_before1st_round.mp4", alt: 'Intro Video 2'},
        {type: 'image', src: "3_page_before1st_round.png", alt: 'Intro Image 3'}
    ];
    let carouselItems = level1TutorialItems; 
    const carouselContainer = document.getElementById('media-container');
    const carouselStatus = document.getElementById('intro-status');
    const carouselPrevBtn = document.getElementById('intro-prev-btn');
    const carouselNextBtn = document.getElementById('intro-next-btn');
    const carouselCloseBtn = document.getElementById('intro-close-btn');
    let currentCarouselIndex = 0;
    function carouselRender(index){ const item = carouselItems[index]; const previousVideo = carouselContainer.querySelector('video'); if (previousVideo) { previousVideo.pause(); } carouselContainer.innerHTML = ''; if(!item) return; let currentMediaElement = null; if(item.type === 'image'){ const img = document.createElement('img'); img.src = item.src; img.alt = item.alt || ''; carouselContainer.appendChild(img); currentMediaElement = img; } else if(item.type === 'video'){ const video = document.createElement('video'); video.src = item.src; video.controls = true; video.autoplay = true; video.muted = true; video.playsInline = true; video.setAttribute('playsinline',''); video.setAttribute('muted',''); carouselContainer.appendChild(video); currentMediaElement = video; video.play().catch(error => { console.log("Autoplay prevented:", error); }); } carouselContainer.appendChild(carouselCloseBtn); carouselStatus.textContent = `${index + 1} / ${carouselItems.length}`; carouselPrevBtn.disabled = index === 0; carouselNextBtn.disabled = index === carouselItems.length - 1; carouselCloseBtn.disabled = false; currentCarouselIndex = index; }
    carouselPrevBtn.addEventListener('click', () => { if (currentCarouselIndex === 0) return; currentCarouselIndex--; carouselRender(currentCarouselIndex); });
    carouselNextBtn.addEventListener('click', () => { if (currentCarouselIndex === carouselItems.length - 1) return; currentCarouselIndex++; carouselRender(currentCarouselIndex); });
    carouselCloseBtn.addEventListener('click', () => { introPopupOverlay.style.display = 'none'; const video = carouselContainer.querySelector('video'); if (video) { video.pause(); video.currentTime = 0; } });
    window.addEventListener('keydown', (e) => { if (introPopupOverlay.style.display !== 'flex') return; if(e.key === 'ArrowLeft') carouselPrevBtn.click(); if(e.key === 'ArrowRight') carouselNextBtn.click(); });
    let startX = 0; let isTouch = false; const stage = document.querySelector('#intro-popup-overlay .stage'); if (stage) { stage.addEventListener('touchstart', (e) => { if (introPopupOverlay.style.display !== 'flex') return; isTouch = true; startX = e.touches[0].clientX; }); stage.addEventListener('touchmove', (e) => { if(!isTouch || introPopupOverlay.style.display !== 'flex') return; const dx = e.touches[0].clientX - startX; if(Math.abs(dx) > 60){ if(dx < 0) carouselNextBtn.click(); else carouselPrevBtn.click(); isTouch = false; } }); stage.addEventListener('touchend', () => { isTouch = false; }); }
    // --- END INTRO SCRIPT ---

    // --- New Rules Popup Logic ---
    function openGameRulesPopup() {
        let title = 'Game Rules: Delivery Challenge';
        let rulesHtml = `
            <div class="popup-body-text">
                <p>Your mission is to deliver ice cream from the truck üöö to the house üè†.</p>
                <ul>
                    <li><strong>Two Goals:</strong> Get the <strong>lowest cost</strong> *and* the <strong>fastest time</strong>!</li>
                    <li><strong>Timer:</strong> The clock starts ticking as soon as you make your first move!</li>
                    <li><strong>Map:</strong>
                        <ul>
                           <li>‚¨ú White Roads = Fast (Cost: 1)</li>
                           <li>üü´ Brown Roads = Slow (Cost: 3)</li>
                           <li>üå≥ Obstacles = Can't go through</li>
                        </ul>
                    </li>
                    <li><strong>Moving:</strong> Click adjacent squares to move. Click your previous square to undo (this adds to your cost and time!).</li>
                </ul>
            </div>
        `;
        
        rulesPopupTitle.innerHTML = title;
        rulesPopupBody.innerHTML = rulesHtml;
        rulesPopupOverlay.style.display = 'flex';
    }

    function closeRulesPopup() {
        rulesPopupOverlay.style.display = 'none';
    }
    // --- End Rules Popup Logic ---

    function getRoundLabelInfo(roundNumber) {
        switch (roundNumber) {
            /* --- MODIFIED: Replaced "Round 1/2/3" with clearer labels --- */
            case 1: return { 
                level: 1, 
                description: "Your 1st Play", 
                title: "Your 1st Play! üöö", 
                scoreLabel: "L1 - Your 1st Play Cost" 
            };
            case 2: return { 
                level: 1, 
                description: "Bot's Play (A*)", 
                title: "Bot's Play! ü§ñ (A* Search)", 
                scoreLabel: "L1 - Bot's Play Cost" 
            };
            case 3: return { 
                level: 1, 
                description: "Your 2nd Play", 
                title: "Your 2nd Play! üç¶", 
                scoreLabel: "L1 - Your 2nd Play Cost" 
            };
            /* --- End of Modification --- */
            default: return { 
                level: 0, 
                description: "Unknown Round", 
                title: "Unknown Round", 
                scoreLabel: "Unknown Cost" 
            };
        }
    }
    function updateRoundTimer() {
        const elapsedSeconds = (Date.now() - roundStartTime) / 1000;
        timeDisplay.innerHTML = `<span>‚è±Ô∏è</span> ${elapsedSeconds.toFixed(1)}s`;
    }

    // --- MAIN GAME FLOW ---
    function setupGame() { 
        resetGameState(); 
        currentRound = 1; 
        createGrid();
        startPlayerTurn(); 
    } 
    function resetGameState() { 
        playerPath = []; 
        playerCost = 0; 
        playerCostRound1 = 0; 
        botPathCost = 0; 
        playerCostRound3 = 0; 
        botAStarLiveSteps = [];
        
        if (roundTimerInterval) clearInterval(roundTimerInterval);
        roundTimerInterval = null;
        roundStartTime = 0;
        playerTimeRound1 = 0;
        playerTimeRound3 = 0;
        botTime = 0;
        
        finishBtn.style.display = 'inline-block'; 
        startNextRoundBtn.style.display = 'none'; 
        rewatchBotBtn.style.display = 'none'; // Hide new button
        finishBtn.disabled = true; 
        hideResultsComparison(); 
        document.getElementById('bot-legend').style.display = 'none'; // Hide legend
    }
    
function startPlayerTurn() { 
        clearVisualization(); 

        // ADDED: Reset timer state and display for the new round
        if (roundTimerInterval) clearInterval(roundTimerInterval);
        roundTimerInterval = null;
        roundStartTime = 0;
        timeDisplay.innerHTML = '<span>‚è±Ô∏è</span> 0.0s';

        document.getElementById('bot-legend').style.display = 'none'; // Hide legend
        if (!startNode) { console.error("Start node not set in startPlayerTurn"); return; } 
        playerPath = [{ ...startNode, costSoFar: 0 }]; 
        playerVisited.clear(); 
        playerVisited.add(`${startNode.row}-${startNode.col}`); 
        playerCost = 0; 
        updatePlayerUI(); 
        boardEl.addEventListener('click', handlePlayerMove); 
        finishBtn.disabled = true; 

        const roundInfo = getRoundLabelInfo(currentRound);
        roundTitleEl.textContent = roundInfo.title;


        switch (currentRound) { 
            case 1: 
                messageBox.textContent = "Click a road next to your truck to start!"; 
                finishBtn.textContent = 'Finish Delivery'; 
                break; 
            case 3: 
                messageBox.textContent = `The bot's best path cost ${botPathCost}. Can you beat it?`; 
                finishBtn.textContent = 'Finish 2nd Try'; 
                break; 
        } 
        if(grid[startNode.row]?.[startNode.col]?.element) { grid[startNode.row][startNode.col].element.textContent = 'üöö'; }
    }
    
    // NEW: Function to show pre-bot popup
    function showAStarIntroPopup() {
        preBotPopup.style.display = 'flex';
    }
    startBotTurnBtn.addEventListener('click', () => {
        preBotPopup.style.display = 'none';
        startBotTurn(); // Now start the actual bot turn
    });

    // NEW: Bot turn
    function startBotTurn() { 
        currentRound = 2; // Bot's turn
        boardEl.removeEventListener('click', handlePlayerMove); 
        const roundInfo = getRoundLabelInfo(currentRound);
        roundTitleEl.textContent = roundInfo.title; 
        
        // Phase 1: "Thinking" (Live Demo)
        messageBox.textContent = "Bot is thinking... Watch the A* Search!"; 
        if (roundTimerInterval) clearInterval(roundTimerInterval);
        timeDisplay.innerHTML = '<span>‚è±Ô∏è</span> Thinking...';
        
        clearPlayerPath(); 
        if(grid[startNode.row]?.[startNode.col]?.element) grid[startNode.row][startNode.col].element.textContent = 'ü§ñ'; 
        
        document.getElementById('bot-legend').style.display = 'block'; // MODIFIED: Show legend (TASK 2)

        // Get the path and the *steps for the live demo*
        findShortestPathAStar(grid, startNode, endNode, (path, steps) => { 
            botPathCost = path.length > 0 ? path[path.length - 1].g : 0; 
            botAStarLiveSteps = steps;
            
            // Play the slow demo on the main board
            animateAStarSearch(botAStarLiveSteps, () => {
                // When demo is done, clear viz and start Phase 2
                clearAStarVizClasses(false); // Keep bot path
                document.getElementById('bot-legend').style.display = 'none'; // MODIFIED: Hide legend (TASK 2)
                
                // Phase 2: "Executing" (Timed Run)
                messageBox.textContent = `Bot found a path! Cost: ${botPathCost}. Executing...`;
                const botTurnStartTime = Date.now();
                timeDisplay.innerHTML = '<span>‚è±Ô∏è</span> 0.0s';
                roundTimerInterval = setInterval(() => {
                    const elapsedSeconds = (Date.now() - botTurnStartTime) / 1000;
                    timeDisplay.innerHTML = `<span>‚è±Ô∏è</span> ${elapsedSeconds.toFixed(1)}s`;
                }, 100);

                animateBotPath(path, `Bot's final path cost: ${botPathCost}!`, () => { 
                    // When animation is done, stop timer
                    if (roundTimerInterval) clearInterval(roundTimerInterval);
                    botTime = (Date.now() - botTurnStartTime) / 1000;
                    timeDisplay.innerHTML = `<span>‚è±Ô∏è</span> ${botTime.toFixed(1)}s`;
                    
                    // Show results
                    showResultsComparison(2);
                    finishBtn.style.display = 'none';
                    // The button-showing lines have been removed from here

                    // ADDED: Delay before showing the popup
                    const popupDelay = 2500; // 2.5-second delay
                    setTimeout(() => {
                        updateAndShowPopup(2); // This opens the teaching popup
                    }, popupDelay);
                });});
        }, true); 
    }
    
    // --- EVENT LISTENERS (NEW FLOW) ---
    finishBtn.addEventListener('click', () => {
        boardEl.removeEventListener('click', handlePlayerMove);
        finishBtn.disabled = true;
        finishBtn.style.display = 'none'; 

        if (roundTimerInterval) clearInterval(roundTimerInterval);
        const elapsedSeconds = (Date.now() - roundStartTime) / 1000;
        timeDisplay.innerHTML = `<span>‚è±Ô∏è</span> ${elapsedSeconds.toFixed(1)}s`;

        if (currentRound === 1) {
            playerCostRound1 = playerCost;
            playerTimeRound1 = elapsedSeconds;
            // Show R1 results in-page and wait
            showResultsComparison(1);
            startNextRoundBtn.textContent = "Start Bot's Turn ü§ñ"; // Changed text
            startNextRoundBtn.style.display = 'inline-block';
            rewatchBotBtn.style.display = 'none';
            
        } else if (currentRound === 3) {
            playerCostRound3 = playerCost;
            playerTimeRound3 = elapsedSeconds;
            // Show R1, R2, R3 results in-page and wait
            showResultsComparison(3);
            startNextRoundBtn.textContent = "See Final Results! üèÜ";
            startNextRoundBtn.style.display = 'inline-block';
            rewatchBotBtn.style.display = 'none';
        }
    });
    
    // Main "Next" button logic
    startNextRoundBtn.addEventListener('click', () => {
        hideResultsComparison();
        startNextRoundBtn.style.display = 'none'; 
        rewatchBotBtn.style.display = 'none';
        finishBtn.style.display = 'inline-block'; 

        if (currentRound === 1) {
            // We're done with R1, now show the PRE-BOT POPUP
            showAStarIntroPopup();
        } else if (currentRound === 2) {
            // This is clicked after closing the popup
            currentRound = 3;
            startPlayerTurn();
        } else if (currentRound === 3) {
            // We're done with R3, show final wrap-up
            showWrapUpPopup('trainee');
        }
    });

    // NEW: Rewatch bot button listener
    rewatchBotBtn.addEventListener('click', () => {
        hideResultsComparison();
        document.getElementById('bot-legend').style.display = 'none'; // MODIFIED: Hide legend (TASK 2)
        rewatchBotBtn.style.display = 'none';
        startNextRoundBtn.style.display = 'none';
        startBotTurn(); // Just re-run the bot's turn
    });


    gameCheckRulesBtn.addEventListener('click', openGameRulesPopup);
    rulesCloseXBtn.addEventListener('click', closeRulesPopup);
    rulesClosePopupBtn.addEventListener('click', closeRulesPopup);

    // --- WRAP-UP POPUP ---
    function showWrapUpPopup(level) {
        wrapUpPerformance.innerHTML = ''; 
        wrapUpButtons.innerHTML = ''; 

        const round1Info = getRoundLabelInfo(1);
        const round2Info = getRoundLabelInfo(2);
        const round3Info = getRoundLabelInfo(3);
        
        wrapUpTitle.textContent = 'Challenge Complete! üç¶';
        
        const bestPlayerCost = Math.min(playerCostRound1, playerCostRound3);
        const beatBotBest = bestPlayerCost <= botPathCost; 

        let resultMessage = '';
        if (beatBotBest) {
            resultMessage = `üéâ Awesome! Your best cost (${bestPlayerCost}) beat (or tied) the bot's ${botPathCost}!`;
        } else {
             resultMessage = `üò• The bot was more efficient this time (${botPathCost} vs your best of ${bestPlayerCost}). Try again!`;
        }

        const scoreDataToSave = {
            level: 1,
            scores: {
                [round1Info.scoreLabel]: playerCostRound1,
                'L1 - Your 1st Try Time': playerTimeRound1.toFixed(1),
                [round2Info.scoreLabel]: botPathCost,
                'L1 - Bot\'s Time': botTime.toFixed(1), // Add bot time
                [round3Info.scoreLabel]: playerCostRound3,
                'L1 - Your 2nd Try Time': playerTimeRound3.toFixed(1)
            }
        };

        wrapUpPerformance.innerHTML = `
            <h4>Performance Summary</h4>
            <p><strong>${round1Info.description}:</strong> &nbsp; <strong>Cost:</strong> ${playerCostRound1} | <strong>Time:</strong> ${playerTimeRound1.toFixed(1)}s</p>
            <p><strong>${round2Info.description}:</strong> &nbsp; <strong>Cost:</strong> ${botPathCost} | <strong>Time:</strong> ${botTime.toFixed(1)}s</p>
            <p><strong>${round3Info.description}:</strong> &nbsp; <strong>Cost:</strong> ${playerCostRound3} | <strong>Time:</strong> ${playerTimeRound3.toFixed(1)}s</p>
            <p style="margin-top: 10px; font-weight: 600;">${resultMessage}</p> 
        `;

        if (window.saveGameResultsToFirebase) {
            window.saveGameResultsToFirebase(scoreDataToSave);
        } else {
            console.warn("Firebase game results save function not found.");
        }

        // --- Add Buttons ---
        const btnAgain = document.createElement('button');
        btnAgain.textContent = `Play Again üîÑüç¶`;
        btnAgain.className = 'player-btn';
        btnAgain.onclick = () => { closeWrapUpPopup(); setupGame(); };
        wrapUpButtons.appendChild(btnAgain);

        const btnNav = document.createElement('button');
        btnNav.textContent = 'Back to Menu üö™';
        btnNav.className = 'bot-btn';
        btnNav.onclick = () => { closeWrapUpPopup(); updateNavigationPage(); showPage('navigation-page'); };
        wrapUpButtons.appendChild(btnNav);

        const btnFinish = document.createElement('button');
        btnFinish.textContent = 'Finish Game üèÅ';
        btnFinish.className = 'finish-game-btn';
        btnFinish.onclick = () => {
            closeWrapUpPopup();
            initializeAppFlow();
        };
        wrapUpButtons.appendChild(btnFinish);
        // --- End Add Buttons ---

        wrapUpPopup.style.display = 'flex'; 
    }
    function closeWrapUpPopup() { wrapUpPopup.style.display = 'none'; }
    
    function calculateTip(cost) {
        let tip = MAX_TIP - ((cost / MAX_COST_PENALTY) * MAX_TIP);
        return Math.max(0, tip);
    }

    function closePopup() { 
        popupOverlay.style.display = 'none'; 
        
        if (currentRound === 2) {
            startNextRoundBtn.textContent = "Start 2nd Try! üöö";
            startNextRoundBtn.style.display = 'inline-block';
            rewatchBotBtn.textContent = "Re-Watch Bot's Turn ü§ñ";
            rewatchBotBtn.style.display = 'inline-block';
        }
    }
    popupGotItBtn.addEventListener('click', closePopup); 
    closeXBtn.addEventListener('click', closePopup);
    

    replayMiniDemoBtn.addEventListener('click', () => {
        setupAStarDemo(); // Just reset the mini-demo
    });


    // --- GRID & MAP GENERATION ---
    function createGrid() {
        boardEl.innerHTML = ''; 
        grid = Array.from({ length: GRID_SIZE }, () => []); 
        for (let r = 0; r < GRID_SIZE; r++) { 
            for (let c = 0; c < GRID_SIZE; c++) { 
                const el = document.createElement('div'); 
                el.className = 'cell'; 
                el.dataset.row = r; el.dataset.col = c; 
                boardEl.appendChild(el); 
                grid[r][c] = { element: el, r, c, cost: FAST_ROAD_COST, isObstacle: false }; 
            } 
        } 
        generateMapLayout();
    }
    function generateMapLayout() { 
        let pathFound; 
        do { 
            grid.flat().forEach(cell => { 
                cell.isObstacle = false; 
                cell.cost = FAST_ROAD_COST;
                cell.element.className = 'cell road-fast'; 
                cell.element.textContent = ''; 
            }); 
            startNode = { row: 0, col: 0 }; 
            endNode = { row: GRID_SIZE - 1, col: GRID_SIZE - 1 }; 
            for (let i = 0; i < OBSTACLE_COUNT; i++) { 
                let r, c; 
                do { 
                    r = ~~(Math.random() * GRID_SIZE); 
                    c = ~~(Math.random() * GRID_SIZE); 
                } while (grid[r]?.[c]?.isObstacle || (r === startNode.row && c === startNode.col) || (r === endNode.row && c === endNode.col)); 
                if(grid[r]?.[c]){ 
                    grid[r][c].isObstacle = true; 
                    grid[r][c].element.classList.add('obstacle'); 
                    grid[r][c].element.textContent = ['üå≥', 'üè´', 'üèõÔ∏è', '‚õ≤'][~~(Math.random()*4)]; 
                } 
            } 
            pathFound = pathExistsCheck(grid, startNode, endNode); 
        } while (!pathFound); 
        
        for (let i = 0; i < SLOW_ROAD_COUNT; i++) { 
            let r, c; 
            do { 
                r = ~~(Math.random() * GRID_SIZE); 
                c = ~~(Math.random() * GRID_SIZE); 
            } while (!grid[r]?.[c] || (r === startNode.row && c === startNode.col) || (r === endNode.row && c === endNode.col) || grid[r][c].isObstacle || grid[r][c].cost !== FAST_ROAD_COST); 
            grid[r][c].cost = SLOW_ROAD_COST; 
            grid[r][c].element.classList.replace('road-fast', 'road-slow'); 
        } 

        if(grid[endNode.row]?.[endNode.col]?.element) { 
            grid[endNode.row][endNode.col].element.textContent = 'üè†'; 
            grid[endNode.row][endNode.col].element.classList.add('end-node-style'); 
        } 
    }
    const isStartOrEnd = (r, c, s, e1) => (r === s.row && c === s.col) || (r === e1.row && c === e1.col);
    
    function handlePlayerMove(e) { 
        if (playerPath.length === 1 && !roundTimerInterval) {
             roundStartTime = Date.now();
             // timeDisplay.innerHTML = '<span>‚è±Ô∏è</span> 0.0s'; // This is now set in startPlayerTurn()
             roundTimerInterval = setInterval(updateRoundTimer, 100);
        }
        const cellEl = e.target.closest('.cell'); 
        if (!cellEl || !grid[+cellEl.dataset.row]?.[+cellEl.dataset.col]) return; 
        const row = +cellEl.dataset.row, col = +cellEl.dataset.col; 
        const clickedCell = grid[row][col]; 
        if (clickedCell.isObstacle) { messageBox.textContent = 'Cannot drive through obstacles!'; return; } 
        
        const lastNode = playerPath[playerPath.length - 1];
        if (!lastNode) return; 

        // Undo move
        if (playerPath.length > 1 && row === playerPath[playerPath.length - 2].row && col === playerPath[playerPath.length - 2].col) { 
            const costOfRoadBack = grid[lastNode.row]?.[lastNode.col]?.cost ?? FAST_ROAD_COST; 
            playerCost += costOfRoadBack;
            const undoneNode = playerPath.pop(); 
            if(undoneNode && (undoneNode.row === endNode.row && undoneNode.col === endNode.col)){
                 boardEl.addEventListener('click', handlePlayerMove); 
            }
            finishBtn.disabled = true; 
            messageBox.textContent = "Going back costs time and cost!";
            updatePlayerUI(); 
            return; 
        }

        // Check adjacency for regular move
        if (Math.abs(row - lastNode.row) + Math.abs(col - lastNode.col) === 1) { 
            playerCost += clickedCell.cost; 
            playerPath.push({ row, col, costSoFar: playerCost }); 
            playerVisited.add(`${row}-${col}`); 

            if (row === endNode.row && col === endNode.col) { 
                messageBox.textContent = `Reached the house! Total cost: ${playerCost}.`; 
                finishBtn.disabled = false; 
                boardEl.removeEventListener('click', handlePlayerMove); 
            } else {
                 messageBox.textContent = 'Keep going!';
                 finishBtn.disabled = true; 
            }
            updatePlayerUI(); 
        } else {
             messageBox.textContent = 'You can only move to squares next to the truck!'; 
        }
    }

    // --- UI & VISUALIZATION ---
    function updatePlayerUI() { 
        clearPlayerPath(); 
        playerVisited.forEach(coord => { 
            const [r, c] = coord.split('-').map(Number); 
            if(grid[r]?.[c]?.element) grid[r][c].element.classList.add('player-visited'); 
        }); 
        playerPath.forEach(p => { 
            if(grid[p.row]?.[p.col]?.element) { 
                const cell = grid[p.row][p.col]; 
                cell.element.classList.remove('player-visited'); 
                cell.element.classList.add('player-path'); 
                addIceCreamIconToCell(cell, p.costSoFar); 
            } 
        }); 
        if(playerPath.length > 0) { 
            const currentPlayerPos = playerPath[playerPath.length-1]; 
            if(grid[currentPlayerPos.row]?.[currentPlayerPos.col]?.element) { 
                grid[currentPlayerPos.row][currentPlayerPos.col].element.textContent = 'üöö'; 
            } 
        } 
        costDisplay.textContent = `Cost: ${playerCost}`; 
        
        const tip = calculateTip(playerCost); 
        tipMeterBar.style.width = `${(tip / MAX_TIP) * 100}%`;
        tipDisplay.textContent = `Tip: $${tip.toFixed(2)}`; 
        
        // MODIFIED: Set innerHTML to an <img> tag using the new function
        iceCreamIcon.innerHTML = `<img src="${getIceCreamImageSrc(playerCost)}" alt="tip icon" style="width: 1.2em; height: 1.2em; vertical-align: middle;">`;
        moneyIcon.textContent = tip > (MAX_TIP * 0.75) ? 'ü§ë' : tip > (MAX_TIP * 0.33) ? 'üôÇ' : 'üò•'; 
    }
    
    function hideResultsComparison() { resultsComparisonEl.style.display = 'none'; resultsComparisonEl.innerHTML = ''; }
    
    // MODIFIED: Replaced hardcoded labels (TASK 1)
    function showResultsComparison(completedRound) { 
        let html = ''; 
        const round1Info = getRoundLabelInfo(1);
        const round2Info = getRoundLabelInfo(2);
        const round3Info = getRoundLabelInfo(3);
        
        switch (completedRound) {
            case 1:
                html = `<h4>${round1Info.description} Complete!</h4>
                        <p>${round1Info.description} Cost: <strong>${playerCostRound1}</strong> <span>(Time: ${playerTimeRound1.toFixed(1)}s)</span></p>`;
                break;
            case 2:
                html = `<h4>${round2Info.description} Complete!</h4>
                        <p>${round1Info.description} Cost: <strong>${playerCostRound1}</strong> <span>(Time: ${playerTimeRound1.toFixed(1)}s)</span></p>
                        <p>${round2Info.description} Cost: <strong>${botPathCost}</strong> <span>(Time: ${botTime.toFixed(1)}s)</span></p>`;
                break;
            case 3:
                html = `<h4>${round3Info.description} Complete!</h4>
                        <p>${round1Info.description} Cost: <strong>${playerCostRound1}</strong> <span>(Time: ${playerTimeRound1.toFixed(1)}s)</span></p>
                        <p>${round2Info.description} Cost: <strong>${botPathCost}</strong> <span>(Time: ${botTime.toFixed(1)}s)</span></p>
                        <p>${round3Info.description} Cost: <strong>${playerCostRound3}</strong> <span>(Time: ${playerTimeRound3.toFixed(1)}s)</span></p>`;
                break;
        }
        
        if (html) { resultsComparisonEl.innerHTML = html; resultsComparisonEl.style.display = 'block'; } 
    }
    
    // NEW: Updated popup text and logic
    function updateAndShowPopup(round) { 
        algoExplanationContainer.style.display = 'none'; 
        let nextRoundInfo = null;

        if (round === 2) { 
            popupTitle.textContent = "Bot's Super Strategy: A* Search!"; 
            popupBody.innerHTML = `<div class="popup-body-text">
                <p><strong>What is A* (A-Star)?</strong><br>
                A* is a "pathfinding" algorithm, like a very smart GPS. It's famous for finding the <strong>lowest-cost</strong> path between two points super fast.</p>
                <p><strong>How We Use It Daily:</strong><br>
                You use A* every day! It's in <strong>Google Maps</strong> finding your route, in 
                <strong>video games</strong> helping characters move, and even in <strong>robotics</strong> for navigation.</p>
                <hr>
                <p><strong>A* Color Key:</strong><br>
                You saw this on the main board. You can also control it in the mini-demo below:</p>
                <ul>
                    <li><span class="color-key" style="background:var(--visited);"></span> <strong>Light Blue:</strong> "To-Check List" (Open Set)</li>
                    <li><span class="color-key" style="background:var(--current-node); border-color: var(--bot-dark);"></span> <strong>Dark Blue:</strong> "Checking NOW!" (Current)</li>
                    <li><span class="color-key" style="background:var(--closed-set-node);"></span> <strong>Grey:</strong> "Already Checked" (Closed Set)</li>
                </ul>
            </div>`; 
            
            nextRoundInfo = getRoundLabelInfo(3);
            popupGotItBtn.textContent = "Okay, I got it!"; // MODIFIED: Changed button text (TASK 1)
            replayMiniDemoBtn.style.display = 'none'; // MODIFIED: Hide replay button (TASK 1)
            
            // Show and set up the interactive demo
            algoExplanationContainer.style.display = 'block'; 
            setupAStarDemo();
        } 
        popupOverlay.style.display = 'flex'; 
    }
    
    // NEW: Live A* Search Animation
    function animateAStarSearch(steps, onComplete) {
        let i = 0;
        const stepDelay = 400; // Slower delay for learning

        function showNextStep() {
            if (i >= steps.length) {
                // Do NOT clear viz classes here, wait for next function
                if (onComplete) onComplete();
                return;
            }

            const step = steps[i];
            
            // Clear only the *previous* live viz classes
            clearAStarVizClasses(false); // false = don't clear final bot path
            
            const start = grid[startNode.row][startNode.col];
            const end = grid[endNode.row][endNode.col];

            // 1. Show Closed Set (Grey)
            step.closedSet.forEach(coord => {
                const [r, c] = coord.split('-').map(Number);
                const cell = grid[r]?.[c];
                if (cell?.element && !isStartOrEnd(r,c,start,end)) {
                    cell.element.classList.add('visited');
                }
            });

            // 2. Show Open Set (Light Blue)
            step.openSet.forEach(node => {
                const cell = grid[node.r]?.[node.c];
                if (cell?.element && !isStartOrEnd(node.r, node.c, start, end)) {
                    cell.element.classList.add('next-consider');
                    addCostLabelToCell(cell.element, node.g, node.h, node.f);
                }
            });
            
            // 3. Show Neighbors being checked (also Light Blue, with labels)
            step.neighbors.forEach(n => {
                const cell = grid[n.r]?.[n.c];
                if (cell && !cell.isObstacle) {
                    cell.element.classList.add('next-consider'); // Light Blue
                    addCostLabelToCell(cell.element, n.g, n.h, n.f);
                }
            });

            // 4. Show Current Node (Dark Blue)
            const currentBotCell = grid[step.current.r]?.[step.current.c];
            if(currentBotCell?.element) {
                currentBotCell.element.classList.remove('next-consider'); // Override light blue
                currentBotCell.element.classList.add('current-bot-pos'); // Dark Blue
                 if (!isStartOrEnd(currentBotCell.r, currentBotCell.c, start, end)) {
                    currentBotCell.element.textContent = 'ü§ñ';
                }
            }
            
            messageBox.textContent = `A* Step ${i+1}: Checking cell (${step.current.r}, ${step.current.c})...`;

            i++;
            setTimeout(showNextStep, stepDelay);
        }
        
        showNextStep();
    }
    
    // Helper to add A* cost labels
    function addCostLabelToCell(cellEl, g, h, f) {
        if (!cellEl) return;
        let costLabel = cellEl.querySelector('.cost-label');
        if (!costLabel) {
            costLabel = document.createElement('div');
            costLabel.className = 'cost-label';
            cellEl.appendChild(costLabel);
        }
        costLabel.innerHTML = `<span class="g-cost">g:${g}</span><span class="h-cost">h:${h}</span><span class="f-cost">f:${f}</span>`;
    }

    // Helper to clear all visualization classes
    function clearAStarVizClasses(clearBotPath = false) {
        const classesToRemove = ['current-bot-pos', 'next-consider', 'visited'];
        if (clearBotPath) {
            classesToRemove.push('bot-path');
        }
        
        grid.flat().forEach(cell => {
            if (!cell || !cell.element) return;
            cell.element.classList.remove(...classesToRemove);
            let oldLabels = cell.element.querySelectorAll('.cost-label');
            oldLabels.forEach(label => label.remove());
            
            if (!cell.isObstacle && !isStartOrEnd(cell.r, cell.c, startNode, endNode)) {
                 if (cell.element.textContent === 'ü§ñ') {
                    cell.element.textContent = '';
                 }
            }
        });
        if (grid[startNode.row]?.[startNode.col]?.element) {
             grid[startNode.row][startNode.col].element.textContent = 'ü§ñ';
        }
    }


    function animateBotPath(path, message, onComplete) { 
        messageBox.textContent = message; 
        let i = 0; 
        const id = setInterval(() => { 
            if (i < path.length) { 
                const cell = path[i]; 
                if(grid[cell.r]?.[cell.c]?.element) grid[cell.r][cell.c].element.classList.add('bot-path'); 
                addIceCreamIconToCell(grid[cell.r]?.[cell.c], cell.g); 
                i++; 
            } else { 
                clearInterval(id); 
                if (onComplete) onComplete(); 
            } 
        }, 80); // Fast animation
    }
    
    function clearVisualization() { 
        grid.flat().forEach(cell => { 
            if(!cell || !cell.element) return; 
            // Remove ALL path/viz classes
            cell.element.classList.remove('player-path', 'player-visited', 'visited', 'bot-path', 'current-bot-pos', 'next-consider'); 
            let existingIcon = cell.element.querySelector('.path-icon'); 
            if (existingIcon) existingIcon.remove(); 
            let costLabel = cell.element.querySelector('.cost-label');
            if(costLabel) costLabel.remove();
            
            if (cell.isObstacle) return; 
            cell.element.textContent = ''; 
            if (startNode && cell.r === startNode.row && cell.c === startNode.col) { /* Don't clear */ } 
            else if (endNode && cell.r === endNode.row && cell.c === endNode.col) { 
                cell.element.textContent = 'üè†';
            }
        }); 
    }
    function clearPlayerPath() { 
        grid.flat().forEach(cell => { 
            if(!cell || !cell.element) return; 
            cell.element.classList.remove('player-path', 'player-visited');
            if (isStartOrEnd(cell.r, cell.c, startNode, endNode) || cell.isObstacle) {} 
            else { cell.element.textContent = ''; } 
            let existingIcon = cell.element.querySelector('.path-icon'); 
            if (existingIcon) existingIcon.remove(); 
        }); 
    } 

    const getIceCreamImageSrc = (cost) => { 
        let penalty = (cost / MAX_COST_PENALTY); // This is a value from 0.0 to 1.0+
        if (penalty > 0.75) return '4.webp'; // e.g., Melted (Cost > 30)
        if (penalty > 0.5)  return '3.webp'; // e.g., Melting (Cost > 20)
        if (penalty > 0.25) return '2.webp'; // e.g., Slightly melting (Cost > 10)
        return '1.webp'; // e.g., Full (Cost 0-10)
    }
    function addIceCreamIconToCell(cell, currentTotalCost) { 
        if(!cell || !cell.element) return; 
        let existingIcon = cell.element.querySelector('.path-icon'); 
        if (existingIcon) existingIcon.remove(); 
        if (cell.isObstacle || isStartOrEnd(cell.r, cell.c, startNode, endNode)) return; 
        
        // MODIFIED: Create an <img> element instead of a <span>
        const iconEl = document.createElement('img'); 
        iconEl.className = 'path-icon'; 
        // MODIFIED: Call the new function and set the .src attribute
        iconEl.src = getIceCreamImageSrc(currentTotalCost); 
        
        cell.element.appendChild(iconEl); 
    }

    // --- A* ALGORITHM & HELPERS ---
    // forLiveDemo flag is now used to generate steps for the LIVE demo
    function findShortestPathAStar(targetGrid, sNode, eNode, callback, forLiveDemo = false) { 
        const gridData = targetGrid.map(row => row.map(cell => ({...cell, cameFrom: null, g: Infinity, h: Infinity, f: Infinity}))); 
        if(!gridData[sNode.row]?.[sNode.col] || !gridData[eNode.row]?.[eNode.col]) { 
            if(callback) callback([], []); return; 
        } 
        const start = gridData[sNode.row][sNode.col]; 
        const end = gridData[eNode.row][eNode.col]; 
        start.g = 0; 
        start.h = heuristic(start, end); 
        start.f = start.h; 
        
        const openSet = [start];
        const closedSet = new Set();
        let pathFound = false;
        let animationSteps = []; 

        while (openSet.length > 0) { 
            openSet.sort((a, b) => a.f - b.f); 
            let current = openSet.shift(); 
            
            if (current.r === end.r && current.c === end.c) { 
                pathFound = true; 
                 if (forLiveDemo) { // Add final step
                    animationSteps.push({
                        current: { r: current.r, c: current.c },
                        openSet: [], closedSet: new Set(closedSet), neighbors: [], chosen: null
                    });
                }
                break; 
            } 
            
            closedSet.add(`${current.r}-${current.c}`); 
            
            let stepState = null;
            if (forLiveDemo) { 
                stepState = {
                    current: { r: current.r, c: current.c },
                    openSet: [...openSet].map(n => ({r: n.r, c: n.c, g: n.g, h: n.h, f: n.f})),
                    closedSet: new Set(closedSet),
                    neighbors: [], // Neighbors will be filled in the next loop
                    chosen: null
                };
                animationSteps.push(stepState);
            } 
            
            let bestNeighbor = null;
            for (const nData of getNeighbors(current, gridData)) { 
                if(!nData) continue; 
                if (nData.isObstacle || closedSet.has(`${nData.r}-${nData.c}`)) continue; 
                
                let tempG = current.g + nData.cost; 
                
                if (forLiveDemo && stepState) {
                     let h = nData.h === Infinity ? heuristic(nData, end) : nData.h;
                     let f = tempG + h;
                     stepState.neighbors.push({ r: nData.r, c: nData.c, g: tempG, h: h, f: f });
                }
                
                if (tempG < nData.g) { 
                    nData.cameFrom = current; 
                    nData.g = tempG; 
                    nData.h = nData.h === Infinity ? heuristic(nData, end) : nData.h; 
                    nData.f = nData.g + nData.h; 
                    
                    if (!openSet.find(node => node.r === nData.r && node.c === nData.c)) {
                        openSet.push(nData); 
                    }
                    
                    if (forLiveDemo && (!bestNeighbor || nData.f < bestNeighbor.f)) {
                        bestNeighbor = nData;
                    }
                } 
            }
            if (forLiveDemo && bestNeighbor && stepState) {
                stepState.chosen = { r: bestNeighbor.r, c: bestNeighbor.c, f: bestNeighbor.f };
            }
        } 
        
        if (pathFound) { 
            const path = []; 
            let temp = gridData[eNode.row][eNode.col]; 
            while (temp) { 
                path.unshift(temp); 
                temp = temp.cameFrom; 
            } 
            if (callback) callback(path, animationSteps); 
        } else { 
            if (callback) callback([], animationSteps); 
        } 
    }
    
    function pathExistsCheck(currentGrid, sNode, eNode) { 
        if (!sNode || !eNode || !currentGrid[sNode.row]?.[sNode.col] || !currentGrid[eNode.row]?.[eNode.col]) return false; 
        const q = [{row: sNode.row, col: sNode.col}], visited = new Set([`${sNode.row},${sNode.col}`]); 
        while (q.length > 0) { 
            const { row, col } = q.shift(); 
            if (row === eNode.row && col === eNode.col) return true; 
            for (const n of getNeighbors({r:row,c:col}, currentGrid)) { 
                if(n && !visited.has(`${n.r},${n.c}`) && !n.isObstacle) { 
                    visited.add(`${n.r},${n.c}`); 
                    q.push({ row: n.r, col: n.c }); 
                } 
            } 
        } 
        return false; 
    }
    const heuristic = (a, b) => Math.abs(a.r - b.r) + Math.abs(a.c - b.c);
    const getNeighbors = (n, currentGrid) => { 
        const ns = [], { r, c } = n, size = currentGrid.length; 
        if (r > 0) ns.push(currentGrid[r-1]?.[c]); 
        if (r < size-1) ns.push(currentGrid[r+1]?.[c]); 
        if (c > 0) ns.push(currentGrid[r]?.[c-1]); 
        if (c < size-1) ns.push(currentGrid[r]?.[c+1]); 
        return ns.filter(Boolean); 
    };

    // --- A* MINI-DEMO LOGIC ---
    function setupAStarDemo() {
        miniGameBoard.innerHTML = '';
        const MINI_GRID_SIZE = 5;
        const demoStartNode = { row: 0, col: 0 };
        const demoEndNode = { row: MINI_GRID_SIZE - 1, col: MINI_GRID_SIZE - 1 };
        
        demoGrid = Array.from({ length: MINI_GRID_SIZE }, (_, r) => 
            Array.from({ length: MINI_GRID_SIZE }, (_, c) => {
                const el = document.createElement('div');
                el.className = 'cell road-fast';
                el.dataset.row = r;
                el.dataset.col = c;
                miniGameBoard.appendChild(el);
                return { element: el, r, c, cost: FAST_ROAD_COST, isObstacle: false };
            })
        );

        // Add obstacles and slow roads
        demoGrid[1][1].isObstacle = true; demoGrid[1][1].element.classList.add('obstacle');
        demoGrid[1][2].isObstacle = true; demoGrid[1][2].element.classList.add('obstacle');
        demoGrid[3][2].isObstacle = true; demoGrid[3][2].element.classList.add('obstacle');
        demoGrid[3][3].isObstacle = true; demoGrid[3][3].element.classList.add('obstacle');
        
        demoGrid[0][2].cost = SLOW_ROAD_COST; demoGrid[0][2].element.classList.replace('road-fast', 'road-slow');
        demoGrid[0][3].cost = SLOW_ROAD_COST; demoGrid[0][3].element.classList.replace('road-fast', 'road-slow');
        demoGrid[1][3].cost = SLOW_ROAD_COST; demoGrid[1][3].element.classList.replace('road-fast', 'road-slow');
        demoGrid[2][3].cost = SLOW_ROAD_COST; demoGrid[2][3].element.classList.replace('road-fast', 'road-slow');

        demoGrid[demoStartNode.row][demoStartNode.col].element.textContent = 'ü§ñ';
        demoGrid[demoEndNode.row][demoEndNode.col].element.textContent = 'üè†';
        demoGrid[demoEndNode.row][demoEndNode.col].element.classList.add('end-node-style');

        // Find path and steps
        findShortestPathAStar(demoGrid, demoStartNode, demoEndNode, (path, steps) => {
            demoPath = steps || [];
            currentDemoStep = 0;
            updateAStarDemoUI();
        }, true); // true = generate steps

        nextStepBtn.onclick = () => {
            currentDemoStep = Math.min(demoPath.length - 1, currentDemoStep + 1);
            updateAStarDemoUI();
        };
        prevStepBtn.onclick = () => {
            currentDemoStep = Math.max(0, currentDemoStep - 1);
            updateAStarDemoUI();
        };
    }

    function updateAStarDemoUI() {
        // Clear all previous styles and labels
        demoGrid.flat().forEach(cell => {
            if(!cell || !cell.element) return;
            cell.element.classList.remove('current-bot-pos', 'next-consider', 'visited', 'bot-path');
            let oldLabels = cell.element.querySelectorAll('.cost-label');
            oldLabels.forEach(label => label.remove());
        });

        if (demoPath.length === 0 || !demoPath[currentDemoStep]) {
            explanationText.textContent = "Could not find a path for the demo.";
            nextStepBtn.disabled = true;
            prevStepBtn.disabled = true;
            return;
        }

        const step = demoPath[currentDemoStep];
        const endNode = demoGrid[demoGrid.length-1][demoGrid.length-1];

        // 1. Show Closed Set (Grey)
        step.closedSet.forEach(coord => {
            const [r, c] = coord.split('-').map(Number);
            const cell = demoGrid[r]?.[c];
            if (cell?.element && !isStartOrEnd(r,c,demoGrid[0][0],endNode)) {
                cell.element.classList.add('visited');
            }
        });

        // 2. Show Open Set (Light Blue)
        step.openSet.forEach(node => {
            const cell = demoGrid[node.r]?.[node.c];
            if (cell?.element && !isStartOrEnd(node.r, node.c, demoGrid[0][0], endNode)) {
                cell.element.classList.add('next-consider');
                addCostLabelToCell(cell.element, node.g, node.h, node.f);
            }
        });
        
        // 3. Show Neighbors being checked (also Light Blue, with labels)
        step.neighbors.forEach(n => {
            const cell = demoGrid[n.r]?.[n.c];
            if (cell && !cell.isObstacle) {
                 cell.element.classList.add('next-consider'); // Light Blue
                 addCostLabelToCell(cell.element, n.g, n.h, n.f);
            }
        });

        // 4. Show Current Node (Dark Blue)
        const currentBotCell = demoGrid[step.current.r]?.[step.current.c];
        if(currentBotCell?.element) {
            currentBotCell.element.classList.remove('next-consider'); // Override light blue
            currentBotCell.element.classList.add('current-bot-pos'); // Dark Blue
        }

        // 5. Update explanation text
        if (step.current.r === endNode.r && step.current.c === endNode.c) {
            explanationText.innerHTML = "Done! The bot reached the house! üéâ";
        } else if (step.chosen) {
             explanationText.innerHTML = `Bot checks neighbors. The lowest F-Score is <strong>${step.chosen.f}</strong> at (${step.chosen.r},${step.chosen.c}). Let's go there next!`;
        } else if (step.neighbors.length > 0) {
            explanationText.innerHTML = `Bot is at (${step.current.r},${step.current.c}) and checking its neighbors...`;
        } else {
             explanationText.innerHTML = `Bot is at (${step.current.r},${step.current.c})... no new neighbors to add.`;
        }

        // Reset text on start/end
        if(demoGrid[endNode.r]?.[endNode.c]?.element) demoGrid[endNode.r][demoGrid.length-1].element.textContent = 'üè†';
        if(demoGrid[0]?.[0]?.element) demoGrid[0][0].element.textContent = 'ü§ñ';

        // 6. Update buttons
        nextStepBtn.disabled = currentDemoStep >= demoPath.length - 1;
        prevStepBtn.disabled = currentDemoStep === 0;
    }


    // --- INITIALIZE APP FLOW ---
    initializeAppFlow();
});
</script>

<script type="module">
  // Firebase initialization
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
  import { getFirestore, doc, setDoc, serverTimestamp, collection, addDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js"; 
  
  const firebaseConfig = { apiKey: "AIzaSyDmMhE1ZeygXoMsSsiwPns8ibnxqxX8aUw", authDomain: "icecreamexpress-6591d.firebaseapp.com", projectId: "icecreamexpress-6591d", storageBucket: "icecreamexpress-6591d.firebasestorage.app", messagingSenderId: "428791114035", appId: "1:428791114035:web:c6b6390ad0043effc6f646", measurementId: "G-L0NGWZ8T9R" };
  const app = initializeApp(firebaseConfig); 
  const analytics = getAnalytics(app); 
  const db = getFirestore(app); 
  console.log("Firebase has been initialized!");

  // --- Function to save user PROFILE data ---
  window.saveUserProfileToFirebase = async (userInfo) => { 
      const userId = localStorage.getItem('iceCreamExpressUserId'); 
      if (!userId) { console.error("No User ID found for profile save."); return; } 
      try { 
          const dataToSave = { 
              ...userInfo, 
              lastLogin: serverTimestamp()
          }; 
          await setDoc(doc(db, "users", userId), dataToSave, { merge: true }); 
          console.log("User profile data saved for:", userId); 
      } catch (e) { 
          console.error("Error saving user profile data: ", e); 
      } 
  };

  // --- Function to save GAME RESULTS data ---
  window.saveGameResultsToFirebase = async (scoreData) => {
      const userId = localStorage.getItem('iceCreamExpressUserId'); 
      const storedUser = localStorage.getItem('iceCreamExpressUser');
      let currentUserInfo = {};
      if (storedUser) {
          currentUserInfo = JSON.parse(storedUser);
      } else {
          console.warn("No current user info found in localStorage for saving game results.");
          currentUserInfo = { firstName: "Unknown", lastNameInitial: "?", age: "?", grade: "?" }; 
      }

      if (!userId) { console.error("No User ID found for game results save."); return; } 
      if (!scoreData || !scoreData.scores) { console.error("No score data provided to save."); return; }

      try {
          const gameResultData = {
              userId: userId,
              userInfo: currentUserInfo,
              level: scoreData.level,
              scores: scoreData.scores, // This now includes the time fields
              completedAt: serverTimestamp()
          };

          const docRef = await addDoc(collection(db, "gameResults"), gameResultData);
          console.log("Game results saved with ID:", docRef.id, "for user:", userId);

      } catch (e) {
          console.error("Error saving game results: ", e);
      }
  };

</script>

</body>
</html>